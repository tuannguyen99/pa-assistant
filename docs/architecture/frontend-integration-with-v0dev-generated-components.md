# Frontend Integration with v0.dev Generated Components

## Integration Architecture

pa-system uses v0.dev for rapid UI prototyping with a layered adapter pattern that maintains separation of concerns while leveraging AI-generated components.

**Component Integration Layers:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND INTEGRATION LAYERS                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 1: Application Layer (Next.js Pages)                      â”‚
â”‚ - Server Components for data fetching                           â”‚
â”‚ - Direct Prisma queries                                         â”‚
â”‚ - Authentication and authorization                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 2: Adapter Layer (Custom Components)                      â”‚
â”‚ - Transform Prisma models to v0 component props                 â”‚
â”‚ - Handle business logic and state management                    â”‚
â”‚ - API integration and error handling                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 3: v0.dev Component Layer (READ-ONLY)                     â”‚
â”‚ - Pure presentation components                                  â”‚
â”‚ - Generated via v0.dev AI                                       â”‚
â”‚ - Never manually edited                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 4: shadcn/ui Primitives (Base Components)                 â”‚
â”‚ - Button, Input, Dialog, Table, etc.                            â”‚
â”‚ - Accessible, customizable, type-safe                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Component Placement Strategy

**Directory Structure:**

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ v0/                      # v0.dev generated components (READ-ONLY)
â”‚   â”‚   â”œâ”€â”€ review-form.tsx      # Generated by v0.dev
â”‚   â”‚   â”œâ”€â”€ target-grid.tsx      # Generated by v0.dev
â”‚   â”‚   â”œâ”€â”€ dashboard.tsx        # Generated by v0.dev
â”‚   â”‚   â””â”€â”€ README.md            # Instructions: DO NOT EDIT
â”‚   â”‚
â”‚   â”œâ”€â”€ adapters/                # Adapter components (CUSTOM)
â”‚   â”‚   â”œâ”€â”€ review-form-adapter.tsx
â”‚   â”‚   â”œâ”€â”€ target-grid-adapter.tsx
â”‚   â”‚   â””â”€â”€ dashboard-adapter.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ reviews/                 # Feature-specific logic components
â”‚   â”‚   â”œâ”€â”€ review-workflow.tsx
â”‚   â”‚   â””â”€â”€ state-machine-handler.tsx
â”‚   â”‚
â”‚   â””â”€â”€ ui/                      # shadcn/ui primitives
â”‚       â”œâ”€â”€ button.tsx
â”‚       â”œâ”€â”€ input.tsx
â”‚       â””â”€â”€ dialog.tsx
```

## Adapter Pattern Implementation

**Example 1: Review Form Integration**

```typescript
// app/(dashboard)/reviews/[id]/page.tsx (Server Component - Layer 1)
import { prisma } from '@/lib/db/prisma'
import { getServerSession } from 'next-auth'
import { ReviewFormAdapter } from '@/components/adapters/review-form-adapter'
import { redirect } from 'next/navigation'

export default async function ReviewPage({ params }: { params: { id: string } }) {
  const session = await getServerSession(authOptions)
  
  // Server-side data fetching with Prisma
  const review = await prisma.review.findUnique({
    where: { id: params.id },
    include: {
      reviewee: {
        select: { id: true, fullName: true, employeeId: true, grade: true }
      },
      reviewer: {
        select: { id: true, fullName: true }
      }
    }
  })
  
  if (!review) {
    redirect('/404')
  }
  
  // Authorization check
  const canAccess = await AuthService.canAccessReview(
    session.user.id,
    review.id,
    session.user.currentRole
  )
  
  if (!canAccess) {
    redirect('/unauthorized')
  }
  
  // Pass Prisma model to adapter
  return <ReviewFormAdapter review={review} currentUser={session.user} />
}

// src/components/adapters/review-form-adapter.tsx (Client Component - Layer 2)
'use client'

import { useState } from 'react'
import { ReviewFormV0 } from '@/components/v0/review-form'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { toast } from '@/components/ui/use-toast'
import type { Review, User } from '@prisma/client'

interface ReviewFormAdapterProps {
  review: Review & {
    reviewee: { id: string; fullName: string; employeeId: string; grade: string }
    reviewer: { id: string; fullName: string }
  }
  currentUser: User
}

export function ReviewFormAdapter({ review, currentUser }: ReviewFormAdapterProps) {
  const queryClient = useQueryClient()
  const [isSubmitting, setIsSubmitting] = useState(false)
  
  // Transform Prisma model to v0 component props
  const v0Props = {
    // Header info
    reviewId: review.id,
    employeeName: review.reviewee.fullName,
    employeeId: review.reviewee.employeeId,
    reviewerName: review.reviewer.fullName,
    cycleYear: review.cycleYear,
    status: review.status,
    
    // Target data transformation
    targets: (review.employeeTargets as any[]).map((target, index) => ({
      id: `target-${index}`,
      description: target.taskDescription,
      kpi: target.kpi,
      weight: target.weight,
      difficulty: target.difficulty,
      employeeRating: target.employeeRating || null,
      resultExplanation: target.resultExplanation || '',
      managerRating: review.managerTargetRatings?.[index]?.managerRating || null,
      managerFeedback: review.managerFeedback?.[index]?.feedback || ''
    })),
    
    // Form state
    currentJobDescription: review.currentJobDesc || '',
    careerPath: review.careerPath || '',
    overallSummary: review.overallSummary || '',
    
    // Permissions
    canEdit: review.status === 'self_eval_draft' && review.revieweeId === currentUser.id,
    canSubmit: review.status === 'self_eval_draft',
    
    // Scores
    finalScore: review.finalScore,
    finalRank: review.finalRank
  }
  
  // Handle form submission with API integration
  const submitMutation = useMutation({
    mutationFn: async (formData: any) => {
      setIsSubmitting(true)
      
      // Transform v0 component data back to Prisma model
      const apiPayload = {
        employeeTargets: formData.targets.map((target: any) => ({
          taskDescription: target.description,
          kpi: target.kpi,
          weight: target.weight,
          difficulty: target.difficulty,
          employeeRating: target.employeeRating,
          resultExplanation: target.resultExplanation,
          aiAssisted: target.aiAssisted || false
        })),
        currentJobDesc: formData.currentJobDescription,
        careerPath: formData.careerPath
      }
      
      const response = await fetch(`/api/reviews/${review.id}/self-eval`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(apiPayload)
      })
      
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error.message)
      }
      
      return response.json()
    },
    onSuccess: () => {
      toast({
        title: 'Success',
        description: 'Review saved successfully'
      })
      queryClient.invalidateQueries({ queryKey: ['review', review.id] })
    },
    onError: (error: Error) => {
      toast({
        variant: 'destructive',
        title: 'Error',
        description: error.message
      })
    },
    onSettled: () => {
      setIsSubmitting(false)
    }
  })
  
  // Handle state transition
  const transitionMutation = useMutation({
    mutationFn: async (targetState: string) => {
      const response = await fetch(`/api/reviews/${review.id}/submit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ targetState })
      })
      
      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error.message)
      }
      
      return response.json()
    },
    onSuccess: () => {
      toast({
        title: 'Success',
        description: 'Review submitted successfully'
      })
      queryClient.invalidateQueries({ queryKey: ['review', review.id] })
    },
    onError: (error: Error) => {
      toast({
        variant: 'destructive',
        title: 'Submission Failed',
        description: error.message
      })
    }
  })
  
  return (
    <ReviewFormV0
      {...v0Props}
      onSave={(formData) => submitMutation.mutate(formData)}
      onSubmit={() => transitionMutation.mutate('self_eval_submitted')}
      isSubmitting={isSubmitting}
    />
  )
}

// src/components/v0/review-form.tsx (v0.dev Generated - Layer 3)
// THIS FILE IS GENERATED BY v0.dev - DO NOT EDIT MANUALLY
// To regenerate, use prompt in docs/v0-prompts/review-form.md

import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'

interface ReviewFormV0Props {
  reviewId: string
  employeeName: string
  employeeId: string
  reviewerName: string
  cycleYear: number
  status: string
  targets: Array<{
    id: string
    description: string
    kpi: string
    weight: number
    difficulty: string
    employeeRating: number | null
    resultExplanation: string
    managerRating: number | null
    managerFeedback: string
  }>
  currentJobDescription: string
  careerPath: string
  overallSummary: string
  canEdit: boolean
  canSubmit: boolean
  finalScore: number | null
  finalRank: string | null
  onSave: (formData: any) => void
  onSubmit: () => void
  isSubmitting: boolean
}

export function ReviewFormV0(props: ReviewFormV0Props) {
  // v0.dev generated UI implementation
  // Pure presentation logic only
  return (
    <div className="space-y-6">
      {/* v0.dev generated glassmorphism UI */}
      <Card className="backdrop-blur-md bg-white/80 dark:bg-gray-900/80">
        <CardHeader>
          <CardTitle>Performance Review - {props.employeeName}</CardTitle>
        </CardHeader>
        <CardContent>
          {/* Render targets, ratings, etc. */}
        </CardContent>
      </Card>
    </div>
  )
}
```

## v0 Component Registry

| v0 Component | Adapter | Data Model | Route | Status |
|--------------|---------|------------|-------|--------|
| `review-form.tsx` | `review-form-adapter.tsx` | `Review` + `Reviewee` + `Reviewer` | `/reviews/[id]` | âœ… Production |
| `target-grid.tsx` | `target-grid-adapter.tsx` | `TargetSetting` | `/targets/[id]` | âœ… Production |
| `dashboard.tsx` | `dashboard-adapter.tsx` | `Review[]` + `User` | `/dashboard/*` | âœ… Production |
| `team-analytics.tsx` | `team-analytics-adapter.tsx` | `Review[]` + aggregations | `/analytics/manager` | ğŸš§ In Progress |
| `hr-consolidation.tsx` | `hr-consolidation-adapter.tsx` | `Review[]` + departments | `/dashboard/hr-consolidation` | ğŸ“‹ Planned |

## Integration Rules

1. **v0 Components are READ-ONLY**
   - Never manually edit files in `src/components/v0/`
   - Regenerate via v0.dev if changes are needed
   - Keep v0 prompt files in `docs/v0-prompts/` for regeneration

2. **Adapters Handle All Logic**
   - Data transformation (Prisma â†” v0 props)
   - API calls and mutations
   - State management (useState, TanStack Query)
   - Error handling and validation
   - Business logic enforcement

3. **Type Safety**
   - Adapters define strict interfaces for v0 components
   - Use Prisma-generated types for database models
   - Validate transformations with Zod schemas

4. **Testing Strategy**
   - Unit test adapters (data transformation, API calls)
   - Integration test full flow (Server Component â†’ Adapter â†’ v0)
   - E2E test user journeys with Playwright

## Data Transformation Patterns

**Pattern 1: Array Mapping (Targets)**
```typescript
// Prisma JSON field to v0 props
const v0Targets = (review.employeeTargets as EmployeeTarget[]).map((target, index) => ({
  id: `target-${index}`,
  description: target.taskDescription,
  kpi: target.kpi,
  weight: target.weight,
  difficulty: target.difficulty,
  rating: target.employeeRating,
  explanation: target.resultExplanation
}))
```

**Pattern 2: Nested Relations**
```typescript
// Prisma include to v0 props
const v0Props = {
  employeeName: review.reviewee.fullName,
  employeeId: review.reviewee.employeeId,
  managerName: review.reviewer.fullName,
  department: review.reviewee.department
}
```

**Pattern 3: Conditional Fields**
```typescript
// Show/hide based on status
const v0Props = {
  showManagerEval: review.status !== 'self_eval_draft',
  showFinalScore: review.status === 'feedback_delivered',
  canEdit: review.status === 'self_eval_draft' && isOwner
}
```

## v0.dev Prompt Templates

Store prompt templates in `docs/v0-prompts/` for consistency:

```markdown
<!-- docs/v0-prompts/review-form.md -->
# v0.dev Prompt: Review Form Component

Create a modern glassmorphism performance review form with:

**Layout:**
- Employee header (name, ID, cycle year, status badge)
- Tabbed interface: Self-Evaluation, Manager Evaluation, History
- Target rating grid (5 targets max)
- Job description textarea
- Career path textarea
- Save draft / Submit buttons

**Styling:**
- Glassmorphism: backdrop-blur, translucent backgrounds
- Tailwind CSS utilities
- shadcn/ui components (Button, Input, Textarea, Card, Tabs)
- Responsive: mobile-first, breakpoints at sm/md/lg
- Dark mode support

**Components to use:**
- shadcn/ui: Button, Input, Textarea, Card, Tabs, Badge
- Star rating component (1-5 stars)
- Status indicator with color coding

**Props interface:**
[Copy ReviewFormV0Props interface here]

**Accessibility:**
- ARIA labels on all inputs
- Keyboard navigation support
- Screen reader friendly
- High contrast colors

Generate the complete TypeScript React component code.
```

## Version Control for v0 Components

```bash
# .gitignore additions
# Track v0 components but mark as generated
src/components/v0/**/*.tsx
# Add comment header in each v0 file:
# THIS FILE IS GENERATED BY v0.dev - DO NOT EDIT
# To regenerate, see: docs/v0-prompts/[component-name].md
# Generated: 2025-11-07
```

## Migration Path

**Phase 1: Initial Integration (Current)**
- Basic adapter pattern established
- Core components (review-form, target-grid, dashboard)
- Manual v0.dev generation and copy-paste

**Phase 2: Automation (Future)**
- Script to auto-generate v0 components via API
- Automated testing of adapters
- CI/CD pipeline validation

**Phase 3: Optimization (Future)**
- Component performance profiling
- Bundle size optimization
- Progressive enhancement

## Component Testing Strategy

**1. Server Component Testing (Integration Tests)**
```typescript
// tests/integration/review-page.test.tsx
import { render, screen } from '@testing-library/react'
import ReviewPage from '@/app/(dashboard)/reviews/[id]/page'
import { prismaMock } from '@/tests/mocks/prisma'

describe('ReviewPage', () => {
  it('renders review data correctly', async () => {
    prismaMock.review.findUnique.mockResolvedValue({
      id: '1',
      reviewee: { fullName: 'John Doe' },
      status: 'self_eval_draft'
    })
    
    const Component = await ReviewPage({ params: { id: '1' } })
    render(Component)
    
    expect(screen.getByText('John Doe')).toBeInTheDocument()
  })
})
```

**2. Client Component Testing (Unit Tests)**
```typescript
// tests/unit/target-setting-form.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { TargetSettingForm } from '@/components/targets/target-setting-form'

describe('TargetSettingForm', () => {
  it('validates total weight equals 100%', async () => {
    const onSubmit = jest.fn()
    render(<TargetSettingForm onSubmit={onSubmit} />)
    
    // Add targets with total weight != 100
    fireEvent.click(screen.getByText('Add Target'))
    
    const submitButton = screen.getByText('Save Targets')
    expect(submitButton).toBeDisabled()
  })
  
  it('enables submit when weight equals 100%', async () => {
    // Test implementation
  })
})
```

**3. E2E Component Flows (Playwright)**
```typescript
// tests/e2e/review-submission.spec.ts
import { test, expect } from '@playwright/test'

test('employee can submit self-evaluation', async ({ page }) => {
  await page.goto('/login')
  await page.fill('[name="username"]', 'john.doe')
  await page.fill('[name="password"]', 'password')
  await page.click('button[type="submit"]')
  
  await page.goto('/reviews/1')
  
  // Rate all targets
  await page.click('[data-testid="target-0-rating-4"]')
  await page.fill('[data-testid="target-0-explanation"]', 'Completed successfully')
  
  // Submit
  await page.click('button:has-text("Submit Self-Evaluation")')
  
  // Verify state change
  await expect(page.locator('[data-testid="review-status"]')).toHaveText('Submitted')
})
```

## Component Performance Optimization

**1. React Server Components (Default)**
- Zero JavaScript sent to client
- Direct database access
- No useState, useEffect needed

**2. Client Component Optimization**
```typescript
// Use React.memo for expensive components
import { memo } from 'react'

export const TargetRatingGrid = memo(function TargetRatingGrid({ targets }) {
  // Only re-renders when targets change
})

// Use useMemo for expensive calculations
import { useMemo } from 'react'

export function ReviewSummary({ review }) {
  const finalScore = useMemo(() => {
    return calculateComplexScore(review)
  }, [review])
  
  return <div>Score: {finalScore}</div>
}

// Use useCallback for callback props
import { useCallback } from 'react'

export function ParentComponent() {
  const handleSubmit = useCallback((data) => {
    // Submit logic
  }, [])
  
  return <ChildComponent onSubmit={handleSubmit} />
}
```

**3. Code Splitting**
```typescript
// Dynamic imports for heavy components
import dynamic from 'next/dynamic'

const AIHelpModal = dynamic(() => import('@/components/ai/ai-help-modal'), {
  loading: () => <LoadingSpinner />,
  ssr: false // Don't render on server
})

export function ReviewForm() {
  return (
    <>
      <Button onClick={() => setShowModal(true)}>Get AI Help</Button>
      {showModal && <AIHelpModal />}
    </>
  )
}
```

**4. Image Optimization**
```typescript
// Use Next.js Image component
import Image from 'next/image'

export function UserAvatar({ user }) {
  return (
    <Image
      src={user.avatarUrl || '/default-avatar.png'}
      alt={user.fullName}
      width={40}
      height={40}
      className="rounded-full"
    />
  )
}
```

## Component Accessibility (WCAG 2.1 AA)

All components follow accessibility best practices:

```typescript
// 1. Semantic HTML
<button type="button">Submit</button>  // Not <div onClick>

// 2. ARIA labels
<button aria-label="Close modal" onClick={onClose}>
  <X />
</button>

// 3. Keyboard navigation
<Dialog
  onKeyDown={(e) => {
    if (e.key === 'Escape') onClose()
  }}
>

// 4. Focus management
import { useEffect, useRef } from 'react'

export function Modal({ open }) {
  const closeButtonRef = useRef<HTMLButtonElement>(null)
  
  useEffect(() => {
    if (open) {
      closeButtonRef.current?.focus()
    }
  }, [open])
  
  return <Dialog>
    <button ref={closeButtonRef}>Close</button>
  </Dialog>
}

// 5. Color contrast (enforced by Tailwind)
<span className="text-gray-900 dark:text-gray-100">
  High contrast text
</span>
```

**shadcn/ui Benefits:**
- âœ… Built on Radix UI (accessible primitives)
- âœ… ARIA attributes included
- âœ… Keyboard navigation support
- âœ… Screen reader tested
- âœ… Focus management built-in

---
